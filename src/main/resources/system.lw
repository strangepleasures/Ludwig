package system

def assert condition message :
	if not condition
		throw message

def assert== a b :
	if != a b
		throw concat list "!= " a " " b

def not x :
	cond x false true

def all seq predicate :
	for x seq
		if not call predicate x
			return false
	true

def xor x y :
	cond x
		not y
		y

def lazy and a b :
	cond a
		b
		false

def lazy or a b :
	cond a
		true
		b

def lazy cond condition option1 option2 :
	if condition
		return option1
	else
		return option2

def neg x :
	* -1 x

def abs x :
	cond < x 0
		neg x 
		x 

def fact n :
	fact0 1 n

def fact0 m n :
	cond == n 0
		m
		fact0 * m n - n 1

def compose f g :
	λ x : call f call g x

def is-null x :
	== x null

def fold seq seed op :
	= result seed
	for x seq
		= result call op result x
	result

def sum seq :
	fold seq 0 ref +

def max seq :
	fold seq
		null
		λ x y :
			cond or < x y is-null x
				y
				x

def min seq :
	= result null
	for x seq
		if or is-null result < x result
			= result x
	result

def any seq predicate :
	for x seq
		if call predicate x
			return true
	false



def concat seq :
	join seq "" "" ""

def each seq consumer :
	for x seq
		call consumer x

def println x :
	print concat list x "\n"

def pi : 3.14159265358979323846

def infinity : / 1.0 0.0

def nan : / 0.0 0.0

def map seq f :
	if is-empty seq
		return seq
	cons
		call f head seq
		map tail seq f

def filter seq pred :
	if is-empty seq
		return seq
	lazy-seq
		cond call pred head seq
			cons head seq
				filter tail seq pred
			filter tail seq pred

def ints start :
	cons start ints + start 1

def keep seq count :
	cond or == count 0 is-empty seq
		list
		cons head seq keep tail seq - count 1

def range start end :
	keep
		ints start
		- end start

def series f :
	map ints 0 f

def >= a b :
	<= b a

def == a b :
	and <= a b <= b a

def != a b :
	not == a b

def > a b :
	not <= a b

def < a b :
	>= b a

def append l x :
	plus l size l x

def prepend l x :
	plus l 0 x